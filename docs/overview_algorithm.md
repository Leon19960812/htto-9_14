# Sequential Convex Programming (SCP) Workflow – Detailed Notes

This document gives a higher-level derivation of the algorithm implemented in the `htto-9_8_version` branch and records the main equations used inside the code base. It is meant as a technical reference for future contributors.

---

## 1. Geometry & State Variables

### 1.1 Polar ground-structure
- Rings are generated by `PolarGeometry` with constant radii \( r^{(k)} \) and initial angles
  \[
  \theta_i^{(0)} = \frac{i}{n_{\text{sectors}}} \pi \qquad (i = 0,\dots,n_{\text{sectors}}).
  \]
- Node coordinates on ring \(k\):
  \[
  (x_i, y_i) = (r^{(k)} \cos \theta_i, \ r^{(k)} \sin \theta_i).
  \]
- Elements are created using a trussopt-style filter (limited angular difference and adjacent radii) to avoid excessively long members.

### 1.2 Optimization variables
- **Angles** \(\theta \in \mathbb{R}^{n_\theta}\): free nodes excluding fixed supports. Update rule follows trust-region constrained steps.
- **Areas** \(A \in \mathbb{R}^{n_e}\): cross-sectional areas with bounds \(A_{\min} \le A \le A_{\max}\).
- **Derived geometry**: Cartesian coordinates
  \[
  \mathbf{x}_i(\theta) = r_i [\cos \theta_i, \sin \theta_i]^T.
  \]
- Material parameters: Young’s modulus \(E_{\text{steel}}\), density, etc., packaged in `MaterialData`.

---

## 2. Shell-based Load Calculation

### 2.1 Shell mesh, stiffness & pressure
The 2D shell (semi-cylindrical slice) is solved by `Shell2DFEA`:
- Membrane stiffness matrix per element:
  \[
  \mathbf{K}_e = \int_{\Omega_e} \mathbf{B}^T \mathbf{D}\, \mathbf{B} \; \mathrm{d}\Omega,
  \]
  with plane-stress constitutive matrix
  \[
  \mathbf{D} = \frac{E_t}{1-\nu^2}
  \begin{bmatrix}
    1 & \nu & 0 \
    \nu & 1 & 0 \
    0 & 0 & (1-\nu)/2
  \end{bmatrix}, \qquad E_t = E_{\text{shell}} \cdot t.
  \]
- Hydrostatic pressure at boundary point \((x,y)\):
  \[
  p(y) = \rho_{\text{water}} g (h - y)_{+}
  \]
  with water depth \(h\). We integrate along each boundary edge using a midpoint rule; the nodal traction contributed by edge \(e = (i,j)\) is
  \[
  \mathbf{f}_e = p(\bar y_e)\, t \cdot L_e \, \mathbf{n}_e,
  \]
  where \(t\) is shell thickness, \(L_e\) edge length, \(\mathbf{n}_e\) outward unit normal evaluated at the midpoint \(\bar y_e\).

### 2.2 Support reactions
The constrained system couples shell displacements \(\mathbf{u}\) and support reactions \(\boldsymbol{\lambda}\):
\[
\begin{bmatrix}
\mathbf{K} & \mathbf{C}^T \
\mathbf{C} & \mathbf{0}
\end{bmatrix}
\begin{bmatrix}
\mathbf{u} \
\boldsymbol{\lambda}
\end{bmatrix} =
\begin{bmatrix}
\mathbf{f}_{\text{pressure}} \
\mathbf{0}
\end{bmatrix}.
\]
- \(\mathbf{C}\) maps selected shell boundary DOFs to virtual supports (Gaussian weights over nearest boundary nodes).
- `solve_with_support_positions()` returns reactions \(\boldsymbol{\lambda}\); the truss experiences the opposite force
  \[
  \mathbf{F}_{\text{truss}} = -\boldsymbol{\lambda}.
  \]
- Debug logging (if enabled) records \(\mathbf{F}_{\text{truss}}\), weights, and incremental changes to diagnose load oscillations.

---

## 3. Truss Equilibrium & Compliance

### 3.1 Element stiffness and global assembly
Each truss element \(e=(i,j)\) contributes the usual 2D bar stiffness:
\[
\mathbf{k}_e = \frac{E_{\text{steel}} A_e}{L_e}
\begin{bmatrix}
 c^2 & cs & -c^2 & -cs \
 cs & s^2 & -cs & -s^2 \
 -c^2 & -cs & c^2 & cs \
 -cs & -s^2 & cs & s^2
\end{bmatrix},
\]
where \(c = \cos\phi_e\), \(s = \sin\phi_e\), \(L_e\) element length, \(A_e\) cross-section. Global stiffness \(\mathbf{K}_{\text{truss}}\) is assembled over free DOFs.

### 3.2 Compliance
- Reduced equilibrium: \(\mathbf{K}_{ff} \mathbf{u}_f = \mathbf{f}_f\) (with constrained DOFs removed).
- Compliance used in the objective:
  \[
  \mathcal{C}(\theta, A) = \mathbf{f}_f^T \mathbf{u}_f = \mathbf{u}_f^T \mathbf{K}_{ff} \mathbf{u}_f.
  \]
- Element volume constraint: \( \sum_e L_e A_e \leq V_{\max}. \)
- Optional AASI buckling thresholds impose lower bounds on \(A_e\) when compressive axial force exceeds critical levels.

---

## 4. Sequential Convex Programming Loop

### 4.1 Linearized subproblem
At iteration \(k\), we linearize compliance and constraints around \((\theta_k, A_k)\). The subproblem solved by `SubproblemSolver` is roughly:
\[
\begin{aligned}
\min_{\Delta\theta,\Delta A} \
& \nabla \mathcal{C}_k^T
\begin{bmatrix}
\Delta\theta \
\Delta A
\end{bmatrix}
+ \frac{1}{2}
\begin{bmatrix}
\Delta\theta \
\Delta A
\end{bmatrix}^T
\mathbf{H}_k
\begin{bmatrix}
\Delta\theta \
\Delta A
\end{bmatrix} \
\text{s.t.}\quad & \text{trust-region: } \|\Delta \theta\|_2 \le r_k,\; |\Delta A| \le \mathbf{m}_k,\
& \text{volume, area bounds, symmetry, etc.}
\end{aligned}
\]
where \(\mathbf{H}_k\) is a convexification (e.g. diagonal/SDP surrogate); output is the candidate \((\theta_{k+1}, A_{k+1}) = (\theta_k + \Delta\theta, A_k + \Delta A)\).

### 4.2 Step quality & trust-region update
With predicted compliance \(\widehat{\mathcal{C}}_{k+1}\) and actual compliance \(\mathcal{C}_{k+1}\), we compute
\[
\rho = \frac{\mathcal{C}_k - \mathcal{C}_{k+1}}{\mathcal{C}_k - \widehat{\mathcal{C}}_{k+1}}.
\]
The implemented policy:
- If \(\rho < 0\) or denominator \(\le 0\) → reject, shrink radius (\(r_{k+1} = \gamma_{\text{shrink}} r_k\)).
- Else if \(\rho > \rho_{\text{high}}\) → accept, possibly enlarge radius.
- Otherwise accept with unchanged radius.

**Important**: each evaluation of \(\mathcal{C}_{k+1}\) recomputes shell loads, so large load differences between trial steps can trigger negative \(\rho\), which is why freezing or relaxing loads is a planned improvement.

### 4.3 Algorithm outline
```
INITIALIZE θ₀, A₀, load_vector(θ₀), compliance C₀
for k = 0,…,kmax:
    Δθ, ΔA, Ĉ = solve_linearized_subproblem(θₖ, Aₖ)
    candidate = (θₖ+Δθ, Aₖ+ΔA)
    compute gradients and (optional) buckling bounds
    # trust-region evaluation
    C_new = actual_compliance(candidate)
    ρ = (Cₖ - C_new)/(Cₖ - Ĉ)
    if ρ < 0 or predicted reduction ≤ 0:
        shrink trust-region, reject step
    else:
        accept step, possibly expand trust-region
        update load_vector via shell FEA, set θₖ₊₁, Aₖ₊₁, Cₖ₊₁
```

---

## 5. Visualization & Logging
- `visualization.py` renders **ground structure**, **optimized truss**, **load distribution** (arrows now scale with full 2D forces), **compliance history**, and **trust-region evolution**.
- `docs/plans/shell_pressure_integration.md` tracks ongoing load-related changes and possible future work (e.g. load freezing).
- `debug_shell_support.log` (enabled via `--shell-debug-log`) is essential for diagnosing load oscillations: it lists support coordinates, Gaussian weights, reactions, and incremental differences.

---

## 6. Known Issues and Planned Enhancements
1. **Load dynamics** – Recomputing shell reactions inside the trust-region line search can trigger large compliance jumps. Literature suggests freezing loads within the inner loop or applying interface relaxation (e.g. Aitken acceleration) to damp oscillations.
2. **Symmetry enforcement** – Ensure node merges keep symmetry pair lists valid; otherwise the solver may unintentionally drop mirror constraints.
3. **Soft supports / coupling stiffness** – If oscillations persist, consider replacing hard reactions with spring-type couplings to the shell, or iterating shell-truss coupling until convergence (like partitioned FSI).
4. **Design-dependent loads** – Future work: integrate the load-carrying boundary identification techniques (e.g. Qu et al., IJNME 2025) to avoid abrupt load reassignments when topology changes.

---

This document should evolve alongside the implementation. When major algorithmic updates happen (load treatment, new constraints, coupling strategies), please revise the corresponding sections and references.
